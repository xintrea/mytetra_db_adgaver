<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Почему же не нужно? Представьте, что автофигура с размеров во весь лист, у неё TopLeftCell - это ячейка A1. Если не учитывать BottomRightCell, то в выделенном диапазонк B2:G20 её как бы и нет, но на самом деле она перекрывает все ячейки. Впрочем, &quot;выбрать все рисунки в выделенном диапазоне ячеек&quot; может иметь и иной смысл - Вам виднее. <br /><br />Вот пример того, как загнать все объекты DrawingObjects заданного диапазона в коллекцию: <br /><br />Sub Test() <br />Dim x, Rng As Range, Col As New Collection <br />Set Rng = Range(&quot;B2:G20&quot;) <br />For Each x In ActiveSheet.DrawingObjects <br />If Not Intersect(Range(x.TopLeftCell, x.BottomRightCell), Rng) Is Nothing Then <br />Debug.Print x.Name <br />Col.Add x <br />End If <br />Next <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">А если кроме рисунков нужны ещё и автофигуры, то у прямоугольников, например, имена могут повторяться (вариант - при копировании), поэтому dic.Add x.Name, ... не есть гуд ;-) <br />В варианте же с коллекцией без ключа собираются все объекты, а не только с уникальными именами</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Sub t() <br />Dim x, dic <br />Set dic = CreateObject(&quot;scripting.dictionary&quot;) <br />For Each x In ActiveSheet.DrawingObjects.ShapeRange <br />If Not Intersect(Selection, x.TopLeftCell) Is Nothing Then <br />dic.Add x.Name, x <br />End If <br />Next <br />ActiveSheet.Shapes.Range(dic.keys).Select <br />Set dic = Nothing <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Sub t() <br />Dim x, dic <br />On Error Resume Next <br />Set dic = CreateObject(&quot;scripting.dictionary&quot;) <br />For Each x In ActiveSheet.DrawingObjects.ShapeRange <br />If Not Intersect(Selection, x.TopLeftCell) Is Nothing Then <br />dic.Add x.DrawingObject.Index, 0 <br />End If <br />Next <br />ActiveSheet.Shapes.Range(dic.keys).Select <br />Set dic = Nothing <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Почти то же самое, но без словаря и с учётом области пересечения по 2-м углам: <br />Sub tt() <br />Dim x, r As Range <br /><br />Set r = ActiveWindow.RangeSelection <br />On Error Resume Next <br />For Each x In ActiveSheet.DrawingObjects.ShapeRange <br />If Not Intersect(Range(x.TopLeftCell, x.BottomRightCell), r) Is Nothing Then x.Select (False) <br />Next x <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Алексей, не понятно, зачем Вам нужно выделять картинки, обычно select - лишнее действие, если это не интерфесная необходимость, конечно. <br /><br />Для коллекции приведу еще пример кода для общего случая, когда нужно хранить группу картинок в переменной ShpsRng для последующих групповых операций. <br /><br />ShpsRng можно было бы объявить и вне процедуры на уровне модуля или глобально. <br /><br />Sub SelectPictures() <br />' Выделение рисунков видимой области экрана <br />Dim a(), i&amp;, n&amp; <br />Dim Shp As Shape, Shps As Shapes, ShpsRng As ShapeRange, Rng As Range <br />Set Shps = ActiveSheet.Shapes <br />If Shps.Count = 0 Then Exit Sub <br />ReDim a(1 To Shps.Count) <br />Set Rng = Windows(1).VisibleRange <br />For i = 1 To Shps.Count <br />With Shps.Item(i) <br />If .Type = msoPicture Then <br />If Not Intersect(Range(.TopLeftCell, .BottomRightCell), Rng) Is Nothing Then <br />n = n + 1 <br />a(n) = i <br />End If <br />End If <br />End With <br />Next <br />If n Then <br />ReDim Preserve a(1 To n) <br />Set ShpsRng = Shps.Range(a) ' ShpsRng может быть и глобальной <br />ShpsRng.Select ' &lt;-- для примера <br />End If <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Попытал разные варианты кода и всё-таки остановился на Володином (с ActiveWindow.RangeSelection). Так получается и короче, и немного корректнее: программа не отказывается работать если выбран не диапазон, а обрабатывает графические объекты, попадающие в диапазон, который был выбран до того, как выбран графический объект: <br />Private Sub Draws_In_Selection_Select() ' выделить все рисунки в выбранном диапазоне <br />Dim oDraw, rSel As Range <br />Set rSel = ActiveWindow.RangeSelection <br />For Each oDraw In ActiveSheet.DrawingObjects.ShapeRange <br />If Not Intersect(Range(oDraw.TopLeftCell, oDraw.BottomRightCell), rSel) Is Nothing Then oDraw.Select (False) <br />Next <br />End Sub</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Меня вполне удовлетворил выбор с Shape.Select(False) <br />Не столько в конце-концов на листе шэйпов чтобы заметить медленность метода. <br />Поэтому оставил так: <br />Private Sub Draws_In_Selection_Select() ' выделить В ВЫБРАННОМ ДИАПАЗОНЕ все рисунки <br />Dim oDraw, rSel As Range <br />Set rSel = ActiveWindow.RangeSelection <br />For Each oDraw In ActiveSheet.DrawingObjects.ShapeRange <br />If Not Intersect(Range(oDraw.TopLeftCell, oDraw.BottomRightCell), rSel) Is Nothing Then oDraw.Select (False) <br />Next <br />End Sub <br /><br />Ну и заодно по такому же принципу слепил макрос, выделяющий на листе все рисунки с нулевыми размерами (они остаются на листе после удаления строк/столбцов): <br /><br />Private Sub Draws_0D_Select() ' выделить НА ЛИСТЕ все рисунки с нулевыми размерами <br />Dim oDraw As Shape <br />For Each oDraw In ActiveSheet.DrawingObjects.ShapeRange <br />If oDraw.Width = 0 Or oDraw.Height = 0 Then oDraw.Select (False) <br />Next <br />End Sub</p></body></html>