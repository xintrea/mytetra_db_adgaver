<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<html>
<main>
        <h1>Руководство по словарям Python</h1>
        <h2>Словари и инструменты для работы с данными Python</h2>
<p>При работе с <span class="strong">Python</span> все время нужно 
временно хранить данные для их последующей обработки в соответствующей 
структуре данных. Язык предоставляет для этого специальную структуру 
данных — <span class="strong">Python словари</span>. В них можно получить доступ к фрагменту данных или значений с помощью ключа (<span class="italic">слова</span>), который у нас есть.</p>
<p>В этом руководстве мы рассмотрим следующие темы:</p>
<ul>
<li>как создать словарь, используя фигурные скобки и двоеточия;</li>
<li>как загрузить данные в словарь с помощью библиотек <span class="strong">urllib</span> и <span class="strong">random</span>;</li>
<li>как фильтровать словарь с помощью цикла <span class="strong">for</span> и специальных итераторов для перебора ключей и значений словаря;</li>
<li>как выполнять операции со словарем для получения или удаления 
значений, и как использовать значения словаря для подмножества значений 
из него;</li>
<li>как сортировать словарь с помощью библиотеки re и как в этом могут помочь функции <span class="strong">OrderedDict</span> и лямбда-функции;</li>
<li>сравним словари <span class="strong">Python</span> со списками, массивами <span class="strong">NumPy</span> и <span class="strong">Pandas DataFrames</span>.</li>
</ul>
<h3>Как создать словарь Python</h3>
<p>Предположим, что вы проводите «<span class="italic">инвентаризацию</span>»
 фруктов, которые положили в корзину, сохраняя количество каждого фрукта
 в словаре. Существует несколько способов создания словаря, но в этом 
руководстве мы используем самые простые. С остальными можно ознакомиться
 в <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" target="_blank" rel="nofollow noopener" class="ym-external-link">документации Python по словарям</a>.</p>
<p>Словари можно распознать по фигурным скобкам <span class="strong">{}</span> и разделению двоеточием <span class="strong">:</span> ключа и значения для каждого элемента.</p>
<p>Переменная <span class="strong">fruit</span> в приведенном ниже коде является допустимым словарем. Получить доступ к элементу <span class="strong">Python</span> словаря можно, поместив ключ между квадратными скобками <span class="strong">[]</span>.Также можно использовать метод <span class="strong">.get()</span>, чтобы сделать то же самое:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pln">fruit </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="str">"apple"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">5</span><span class="pun">,</span><span class="pln"> </span><span class="str">"pear"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="str">"banana"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="str">"pineapple"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">https</span><span class="pun">:</span><span class="com">//www.datacamp.com/community/tutorials/python-dictionary-tutorial "cherry" : 20}</span></li><li class="L1"><span class="com"># Получаем доступ к словарю `fruit` непосредственно (без использования get) и выводим значение "banana"</span></li><li class="L2"><span class="kwd">print</span><span class="pun">(</span><span class="pln">_____</span><span class="pun">[</span><span class="str">"______"</span><span class="pun">])</span></li><li class="L3"><span class="com"># Выбираем один из 5 фруктов и показываем, что оба способа извлечения дают аналогичные результаты</span></li><li class="L4"><span class="kwd">print</span><span class="pun">(</span><span class="pln">fruit</span><span class="pun">[</span><span class="str">"_____"</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> fruit</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">"_____"</span><span class="pun">))</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<h3>Загрузка данных в словарь Python</h3>
<p>Теперь мы поместим данные во вложенный словарь, который содержит в 
качестве значения другой словарь, а не строку или целое число. Таким 
образом, в словарь можно сохранять таблицы или матрицы.</p>
<p>Используемые данные — это отзывы на <span class="strong">Amazon</span> о книге Донны Тартт «<span class="strong"><span class="italic">The Goldfinch</span></span>«. Они были сохранены в простом файле с разделителями. Таблица содержит четыре столбца: оценка, <span class="strong">URL-адрес</span>, заголовок отзыва и текст отзыва.</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-A"><div class="block block-174 type-custom "><div class="field field-528">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 185px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="1901069998" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><p>Есть несколько способов представить эти данные в <span class="strong">Python</span> словаре, но в нашем случае мы берем <span class="strong">URL-адрес</span> в качестве ключа и помещаем другие столбцы в словарь с вложенными значениями:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">import</span><span class="pln"> urllib</span></li><li class="L1"><span class="kwd">import</span><span class="pln"> random</span></li><li class="L2"><span class="com"># Загружаем данные из удаленного места (URL-адреса)</span></li><li class="L3"><span class="pln">file </span><span class="pun">=</span><span class="pln"> urllib</span><span class="pun">.</span><span class="pln">request</span><span class="pun">.</span><span class="pln">urlopen</span><span class="pun">(</span><span class="str">"https://gist.githubusercontent.com/twielfaert/a0972bf366d9aaf6cb1206c16bf93731/raw/dde46ad1fa41f442971726f34ad03aaac85f5414/Donna-Tartt-The-Goldfinch.csv"</span><span class="pun">)</span></li><li class="L4"><span class="pln">f </span><span class="pun">=</span><span class="pln"> file</span><span class="pun">.</span><span class="pln">read</span><span class="pun">()</span></li><li class="L5"><span class="com"># Преобразуем битовый поток в строки</span></li><li class="L6"><span class="pln">text </span><span class="pun">=</span><span class="pln"> f</span><span class="pun">.</span><span class="pln">decode</span><span class="pun">(</span><span class="pln">encoding</span><span class="pun">=</span><span class="str">'utf-8'</span><span class="pun">,</span><span class="pln">errors</span><span class="pun">=</span><span class="str">'ignore'</span><span class="pun">)</span></li><li class="L7"><span class="com"># Разбиваем эту одну строку на концах линий</span></li><li class="L8"><span class="pln">lines </span><span class="pun">=</span><span class="pln"> text</span><span class="pun">.</span><span class="pln">split</span><span class="pun">(</span><span class="str">"n"</span><span class="pun">)</span></li><li class="L9"><span class="com"># Инициализируем словарь</span></li><li class="L0"><span class="pln">reviews </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{}</span></li><li class="L1"><span class="com"># Заполняем словарь</span></li><li class="L2"><span class="kwd">for</span><span class="pln"> line </span><span class="kwd">in</span><span class="pln"> lines</span><span class="pun">:</span></li><li class="L3"><span class="pln">  l </span><span class="pun">=</span><span class="pln"> line</span><span class="pun">.</span><span class="pln">strip</span><span class="pun">().</span><span class="pln">split</span><span class="pun">(</span><span class="str">"t"</span><span class="pun">)</span></li><li class="L4"><span class="pln"> </span></li><li class="L5"><span class="pln">  </span><span class="com"># Это просто тестовые данные, чтобы посмотреть, что входит в словарь</span></li><li class="L6"><span class="pln">  score </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span></li><li class="L7"><span class="pln">  id </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span></li><li class="L8"><span class="pln">  title </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span></li><li class="L9"><span class="pln">  review </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="pln">  reviews</span><span class="pun">[</span><span class="pln">id</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="str">"score"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> score</span><span class="pun">,</span><span class="pln"> </span><span class="str">"title"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> title</span><span class="pun">,</span><span class="pln"> </span><span class="str">"review"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> review</span><span class="pun">}</span></li><li class="L2"><span class="com"># Берем случайный ключ из словаря и выводим его значение</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Мы получили набор данных, в котором нет отсутствующих значений. Но 
можно проверить, присутствуют ли все ключи в словаре, сравнив количество
 строк из файла с количеством ключей словаря. В нашем случае вот как 
можно осуществить <span class="strong">Python</span> сортировку словаря:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="com"># Подсчитываем количество строк в файле</span></li><li class="L1"><span class="kwd">print</span><span class="pun">(</span><span class="str">"Количество строк: "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> str</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">lines</span><span class="pun">)))</span></li><li class="L2"><span class="com"># Подсчитываем количество ключей в словаре; оно должно равняться количеству строк в файле</span></li><li class="L3"><span class="kwd">print</span><span class="pun">(</span><span class="str">"Количество ключей словаря: "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> str</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">reviews</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">())))</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<h3>Как отфильтровать словарь Python</h3>
<p>Теперь, когда отзывы хранятся в словаре, пришло время попробовать 
выполнить некоторые операции. Допустим, вы хотите посмотреть, что на 
самом деле написали люди, выбрав только отзывы с оценкой <span class="strong">1.0</span>.</p>
<p>Оценки хранятся в значениях словаря, поэтому придется перебирать словарь. Для этого можно использовать цикл <span class="strong">for</span>.</p>
<p>Элементы словаря <span class="strong">Python</span> имеют не только ключ и значение, но и специальный итератор для их перебора. Вместо <span class="strong">for item in dictionary</span> необходимо использовать <span class="strong">for key</span>, <span class="strong">value in dictionary.items()</span>. При этом должны использоваться две переменные, ключ и значение, а не одна.</p>
<p>Существуют отдельные итераторы для ключей <span class="strong">(.keys())</span> и значений <span class="strong">(.values())</span>.</p>
<p>Мы сохраняем ключи отзывов с низкой оценкой в списке с именем <span class="strong">lowscores</span>. Благодаря этому в дальнейшем можно будет повторно использовать список, чтобы извлечь отзывы из словаря:</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-B"><div class="block block-175 type-custom "><div class="field field-555">

<ins class="adsbygoogle" style="display:inline-block;width:580px;height:400px" data-ad-client="ca-pub-7264282846152864" data-ad-slot="4724268713" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:400px;margin:0;padding:0;position:relative;visibility:visible;width:580px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:400px;margin:0;padding:0;position:relative;visibility:visible;width:580px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:580px;height:400px;" width="580" height="400" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="com"># Сохраняем ключи отзывов с низкой оценкой (1.0) в списке</span></li><li class="L1"><span class="pln">lowscores </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[]</span></li><li class="L2"><span class="kwd">for</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">value</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> reviews</span><span class="pun">.</span><span class="pln">items</span><span class="pun">():</span></li><li class="L3"><span class="pln">  </span><span class="kwd">if</span><span class="pln"> </span><span class="kwd">float</span><span class="pun">(</span><span class="kwd">value</span><span class="pun">[</span><span class="str">"score"</span><span class="pun">])</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">:</span><span class="pln"> </span><span class="com"># Convert score to float</span></li><li class="L4"><span class="pln">    lowscores</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="pln">key</span><span class="pun">)</span></li><li class="L5"><span class="com"># Выводим все записи с низкой оценкой</span></li><li class="L6"><span class="kwd">for</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> __________</span><span class="pun">:</span></li><li class="L7"><span class="pln">  </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">reviews</span><span class="pun">[</span><span class="pln">____</span><span class="pun">])</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<h3>Операции над словарями Python</h3>
<p>Если словарь, содержащий полный набор данных, большой, то разумнее использовать список <span class="strong">lowscores</span>, который мы только что скомпилировали, чтобы создать совершенно новый словарь (<span class="strong"><span class="italic">Python список в словарь</span></span>).
 Преимущество этого приема заключается в том, что для дальнейшего 
анализа не нужно хранить в памяти большой словарь. Можно просто перейти к
 соответствующему подмножеству исходных данных.</p>
<p>Во-первых, мы используем ключи, хранящиеся в <span class="strong">lowscores</span>,
 для создания нового словаря. Чтобы сделать это, есть два способа: 
первый — извлекаем только соответствующие элементы из исходного словаря с
 помощью метода <span class="strong">.get()</span>, оставляя исходный словарь без изменений. Второй — использовать метод <span class="strong">.pop()</span>, который удаляет извлеченные записи из исходного словаря.</p>
<p>Код для подмножества может выглядеть следующим образом: <span class="strong">subset = dict([(k, reviews.get(k)) for k in lowscores])</span>. Такое написание может показаться незнакомым, потому что цикл задан одной строкой кода. Этот стиль называется «<span class="italic">генерацией словаря</span>». На самом деле это цикл <span class="strong">for</span>, который перебирает элементы <span class="strong">lowscores</span>, извлекает значения из отзывов и использует их для заполнения нового словаря.</p>
<p>Вы можете сравнить традиционный стиль с использованием цикла и 
генерацию словаря и убедиться, что они действительно дают идентичный 
результат:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="com"># Метод с использованием цикла for для создания подмножества словаря</span></li><li class="L1"><span class="pln">forloop </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{}</span></li><li class="L2"><span class="kwd">for</span><span class="pln"> k </span><span class="kwd">in</span><span class="pln"> lowscores</span><span class="pun">:</span></li><li class="L3"><span class="pln">  forloop</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> reviews</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]</span></li><li class="L4"><span class="com"># Добавляем специальный метод извлечения релевантных элементов из словаря `reviews`</span></li><li class="L5"><span class="pln">dictcomp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">k </span><span class="pun">:</span><span class="pln"> reviews</span><span class="pun">.</span><span class="pln">___</span><span class="pun">(</span><span class="pln">k</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> k </span><span class="kwd">in</span><span class="pln"> lowscores</span><span class="pun">}</span></li><li class="L6"><span class="com"># Удостоверимся, что эти объекты аналогичны</span></li><li class="L7"><span class="kwd">print</span><span class="pun">(</span><span class="pln">forloop </span><span class="pun">==</span><span class="pln"> ________</span><span class="pun">)</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Предположим, что теперь вы хотите изменить словарь <span class="strong">Python 3</span>, чтобы оценки выступали в качестве ключей словаря, а не идентификаторов. Можно использовать для этого цикл <span class="strong">for</span>, указав как ключи, так и значения, и создав новый вложенный словарь. Нужно будет извлечь «<span class="strong"><span class="italic">score</span></span>» из исходного вложенного словаря, чтобы использовать его в качестве нового ключа.</p>
<p>Чтобы упростить код, мы создаем в отдельной строке новый вложенный словарь как новый объект <span class="strong">newvalues</span>. После чего заполняем <span class="strong">scoredict</span> идентификаторами в качестве ключей и объектами из словаря <span class="strong">newvalues</span> в качестве значений:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">from</span><span class="pln"> collections </span><span class="kwd">import</span><span class="pln"> defaultdict</span></li><li class="L1"><span class="pln">scoredict </span><span class="pun">=</span><span class="pln"> defaultdict</span><span class="pun">(</span><span class="pln">list</span><span class="pun">)</span></li><li class="L2"><span class="kwd">for</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">value</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> reviews</span><span class="pun">.</span><span class="pln">items</span><span class="pun">():</span></li><li class="L3"><span class="pln">  newvalues </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="str">'id'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="str">"title"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">[</span><span class="str">'title'</span><span class="pun">],</span><span class="pln"> </span><span class="str">"review"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">[</span><span class="str">'review'</span><span class="pun">]}</span></li><li class="L4"><span class="pln">  </span><span class="com"># Используем 'score' из значений (!) из исходного словаря в качестве ключей для только что созданного  словаря</span></li><li class="L5"><span class="pln">  scoredict</span><span class="pun">[</span><span class="pln">_____</span><span class="pun">[</span><span class="str">'_____'</span><span class="pun">]].</span><span class="pln">append</span><span class="pun">(</span><span class="pln">newvalues</span><span class="pun">)</span></li><li class="L6"><span class="pln"> </span></li><li class="L7"><span class="com"># Выводим ключи словаря, чтобы удостовериться, что это на самом деле оценки из отзывов</span></li><li class="L8"><span class="kwd">print</span><span class="pun">(</span><span class="pln">scoredict</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">())</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-C"><div class="block block-176 type-custom "><div class="field field-530">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 185px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="3929425397" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><h3>Как сортировать словари на Python</h3>
<p>Мы попробовали загрузить в словарь реальный набор данных, теперь 
можно выполнить их простой анализ. Если вы хотите знать, что именно 
пишут люди, ставящие низкую оценку роману, можно провести <span class="strong">Python</span> сортировку словаря, создав список частоты использования слов в отрицательных отзывах (<span class="italic">оценка 1.0</span>).</p>
<p>Нам нужно немного обработать текст отзывов, удалив <span class="strong">HTML-теги</span>
 и конвертировав заглавные буквы в словах в нижний регистр. Для первой 
задачи мы используем регулярное выражение, которое удаляет все теги: <span class="strong">re.sub(«», «»)</span>. <a href="https://developers.google.com/edu/python/regular-expressions" target="_blank" rel="nofollow noopener" class="ym-external-link">Регулярные выражения</a>
 — это полезный инструмент при работе с текстовыми данными. Они довольно
 сложны для компиляции и заслуживают отдельного руководства.</p>
<p>Но в нашем примере нужно просто определить наборы символов, которые начинаются с символа &lt;, за которым следует произвольное количество символов, после чего стоит символ &gt;. И заменить их на пустые кавычки <span class="strong">«»</span> (<span class="italic">ничего</span>).</p>
<p><span class="strong">Python</span> содержит встроенную функцию для удаления заглавных букв из слов, нужно просто привязать функцию <span class="strong">.lowercase()</span> к строке. Таким образом, можно избавиться от слов, начинающихся с заглавной буквы, которые встречаются в начале предложений.</p>
<p>Затем мы создаем частотный словарь, используя <span class="strong">defaultdict</span> вместо обычного словаря. Это гарантирует, что каждый «<span class="italic">ключ</span>» уже инициализирован, и можно просто увеличивать его частоту, начиная с <span class="strong">1</span>.</p>
<p>Если вы не используете <span class="strong">defaultdict</span>, <span class="strong">Python</span> может выдать ошибку при первом увеличении частоты (<span class="italic">с 0 до 1</span>), потому что ключ еще не существует. Этого можно избежать, предварительно проверив, существует ли ключ в <span class="strong">Python</span> словаре, прежде чем увеличивать значение его частоты. Но это решение не такое элегантное, как <span class="strong">defaultdict</span>:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">import</span><span class="pln"> re</span></li><li class="L1"><span class="com"># Импортируем defaultdict</span></li><li class="L2"><span class="kwd">from</span><span class="pln"> collections </span><span class="kwd">import</span><span class="pln"> ___________</span></li><li class="L3"><span class="pln">freqdict </span><span class="pun">=</span><span class="pln"> defaultdict</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span></li><li class="L4"><span class="kwd">for</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> lowscores</span><span class="pun">:</span></li><li class="L5"><span class="pln">  review </span><span class="pun">=</span><span class="pln"> reviews</span><span class="pun">[</span><span class="pln">item</span><span class="pun">][</span><span class="str">"review"</span><span class="pun">]</span></li><li class="L6"><span class="pln">  cleantext </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">r</span><span class="str">'&lt;.*?&gt;'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> review</span><span class="pun">).</span><span class="pln">strip</span><span class="pun">().</span><span class="pln">split</span><span class="pun">()</span><span class="pln"> </span><span class="com"># Remove HTML tags and split the review by word (space separated)</span></li><li class="L7"><span class="pln">  </span><span class="kwd">for</span><span class="pln"> word </span><span class="kwd">in</span><span class="pln"> cleantext</span><span class="pun">:</span></li><li class="L8"><span class="pln">   </span><span class="com"># Конвертируем все буквы в нижний регистр</span></li><li class="L9"><span class="pln">    word </span><span class="pun">=</span><span class="pln"> word</span><span class="pun">.</span><span class="pln">lower</span><span class="pun">()</span></li><li class="L0"><span class="pln"> </span></li><li class="L1"><span class="pln">    </span><span class="com"># Заполняем следующую строку, чтобы увеличить частоту на один:</span></li><li class="L2"><span class="pln">    freqdict</span><span class="pun">[</span><span class="pln">word</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> _</span></li><li class="L3"><span class="pln"> </span></li><li class="L4"><span class="kwd">print</span><span class="pun">(</span><span class="pln">freqdict</span><span class="pun">)</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>После того, как наш частотный словарь будет готов, все равно нужно будет осуществить <span class="strong">Python</span>
 сортировку словаря по значению в порядке убывания, чтобы быстро 
увидеть, какие слова употребляются чаще всего. Поскольку стандартные 
словари (<span class="italic">в том числе <span class="strong">defaultdict</span></span>) не могут быть отсортированы определенным образом, нужно использовать другой класс, а именно <span class="strong">OrderedDict</span>.
 Он хранит элементы словаря в порядке их добавления. В этом случае 
сначала нужно отсортировать элементы, прежде чем сохранять их снова в 
класс <span class="strong">OrderedDict</span>.</p>
<p>Функция <span class="strong">sorted</span> принимает три аргумента. 
Первый — это объект, который нужно отсортировать, наш частотный словарь.
 При этом необходимо помнить, что доступ к парам ключ-значение в словаре
 возможен только через функцию <span class="strong">.items()</span>. Если вы забудете об этом, <span class="strong">Python</span>
 даже не выдаст предупреждение, а только вернет первый ключ, который 
встретит. Другими словами: если вы перебираете словарь, и ваш код ведет 
себя странным образом, проверьте, добавлена ли функция <span class="strong">.items()</span>.</p>
<p>Второй аргумент указывает, какую часть первого аргумента следует использовать для сортировки: <span class="strong">key=lambda item: item[1]</span>. Но вам придется более углубленно изучить язык <span class="strong">Python</span>, чтобы понять, что это такое. Первая часть довольно понятна: вы хотите, чтобы ключи сортировались.</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-D"><div class="block block-177 type-custom "><div class="field field-531">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 0px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="2005011772" data-adsbygoogle-status="done"><ins id="aswift_3_expand" style="display: inline-table; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent;"><ins id="aswift_3_anchor" style="display: block; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_3" name="aswift_3" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><p>Но что там делает <span class="strong">lambda</span>?
 Она является анонимной функцией, то есть это функция без имени, которая
 не может быть вызвана извне. Это альтернативный способ обработки через 
цикл целого ряда объектов с помощью одной функции. В данном случае 
используется значение словаря <span class="italic">(<span class="strong">item[1]</span>, при <span class="strong">item[0]</span> выступающем в качестве ключа</span>) в качестве аргумента для сортировки.</p>
<p>Третий (<span class="italic">последний</span>) аргумент, <span class="strong">reverse</span>, указывает, должна ли сортировка выполняться по возрастанию (<span class="italic">по умолчанию</span>) или по убыванию. В данном случае мы хотим увидеть наиболее часто встречающиеся слова вверху и указываем <span class="strong">reverse=True</span>.</p>
<p>Прямо сейчас вы были бы разочарованы словами, которые располагаются в
 самом верху списка отсортированных элементов. Это были бы просто «<span class="italic">функциональные слова</span>», такие как «<span class="strong"><span class="italic">the</span></span>», «<span class="strong"><span class="italic">and</span></span>», «<span class="strong"><span class="italic">a</span></span>»
 и т. д. В английском, как и во многих других языках, эти слова 
употребляются достаточно часто. Но при этом они совершенно бессмысленны 
сами по себе.</p>
<p>В текстовой аналитике для удаления этих высокочастотных слов 
используются так называемые стоп-листы. Мы же применим более примитивный
 подход, игнорируя верхние 10% слов и рассматривая только слова, которые
 относятся к остальным 90%. Вы увидите, что в верхней части списка 
представлены как слова с негативным оттенком, такие как «<span class="italic">неинтересно</span>» и «<span class="italic">разочаровывающе</span>», так и более позитивные: «<span class="italic">увлекательно</span>» и «<span class="italic">чудесно</span>».</p>
<p>Можно поэкспериментировать и посмотреть, в каких частях <span class="strong">Python</span> словаря можно найти интересные слова:</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">from</span><span class="pln"> collections </span><span class="kwd">import</span><span class="pln"> </span><span class="typ">OrderedDict</span></li><li class="L1"><span class="com"># Создаем словарь Ordered</span></li><li class="L2"><span class="pln">ordict </span><span class="pun">=</span><span class="pln"> </span><span class="typ">OrderedDict</span><span class="pun">(</span><span class="pln">sorted</span><span class="pun">(</span><span class="pln">freqdict</span><span class="pun">.</span><span class="pln">items</span><span class="pun">(),</span><span class="pln"> key</span><span class="pun">=</span><span class="kwd">lambda</span><span class="pln"> item</span><span class="pun">:</span><span class="pln"> item</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> reverse</span><span class="pun">=</span><span class="kwd">True</span><span class="pun">))</span></li><li class="L3"><span class="com"># Игнорируем верхние 10%</span></li><li class="L4"><span class="pln">top10 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">ordict</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">())/</span><span class="lit">10</span><span class="pun">)</span></li><li class="L5"><span class="com"># Выводим 100 слов из верхних 90%</span></li><li class="L6"><span class="kwd">print</span><span class="pun">(</span><span class="pln">list</span><span class="pun">(</span><span class="pln">ordict</span><span class="pun">.</span><span class="pln">items</span><span class="pun">())[</span><span class="pln">top10</span><span class="pun">:</span><span class="pln">top10</span><span class="pun">+</span><span class="lit">100</span><span class="pun">])</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<h3>Сравнение словарей со списками Python, массивами NumPy и Pandas DataFrames</h3>
<p>Словари — важная структура данных <span class="strong">Python</span>,
 позволяющая поместить данные в объекты для дальнейшей обработки. Они, 
наряду со списками и кортежами, являются одной из основных, наиболее 
мощных и гибких структур данных <span class="strong">Python</span>. Но в последнее время большая часть функциональных возможностей словаря может быть заменена и заменяется <a href="http://pandas.pydata.org/" target="_blank" rel="nofollow noopener" class="ym-external-link">Pandas</a>, библиотекой анализа данных <span class="strong">Python</span>. Она позволяет лучше обрабатывать и анализировать данные на <span class="strong">Python</span>, и при этом не нужно использовать сторонние специализированные языки статистического программирования (<span class="italic">в частности, <span class="strong">R</span></span>).</p>
<p>Такие библиотеки, как <span class="strong">Pandas</span>, позволяют 
обработчикам данных работать быстрее и эффективнее. Им больше не нужно 
беспокоиться о деталях более низкого уровня, касающихся того, как 
хранятся данные. Но <span class="strong">Pandas</span> также использует словари (<span class="italic">наряду с другими расширенными структурами данных, такими как массив <span class="strong">NumPy</span></span>) для хранения данных.</p>
<p>Даже при применении <span class="strong">Pandas</span> иногда рекомендуется использовать словари. Например, когда значения необходимо просто сопоставить, и вам не нужны функции <span class="strong">Pandas</span> ни для чего другого. Использование объекта <span class="strong">Pandas</span> в таких случаях просто неэффективно и излишне.</p>
<p><span class="strong">Pandas</span> включает в себя функции для преобразования словаря в <span class="strong">Pandas DataFrame</span>, и наоборот, а <span class="strong">DataFrame</span> может осуществлять <span class="strong">Python</span> сортировку словаря. Оба они действительно являются полезными частями современного инструментария.</p>
<p>Перевод статьи «<a href="https://www.datacamp.com/community/tutorials/python-dictionary-tutorial" target="_blank" rel="nofollow noopener" class="ym-external-link">Python Dictionary Tutorial</a>» дружной командой проекта <a href="http://www.internet-technologies.ru/" target="_blank">Сайтостроение от А до Я</a>.</p>
    </main>
</body>
</html></p></body></html>