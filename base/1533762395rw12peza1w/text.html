<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<html>
<main>
        <h1>Программирование метаклассов на Python</h1>
        <h3>Поднятие объектно-ориентированного программирования на новый уровень</h3>
<p>Большинство читателей уже знакомо с концепциями 
объектно-ориентированного программирования: наследованием, 
инкапсуляцией, полиморфизмом. Но создание объектов заданного класса с 
определенными родителями обычно представляется исходно заданной 
операцией. Оказывается, что ряд новых программных конструкций становится
 либо более простым, либо вообще хоть сколько-нибудь возможным, если вы 
можете настраивать процесс создания объектов. Метаклассы разрешают 
определенные типы "аспектно-ориентированного программирования"; 
например, можно усилить классы такими характеристиками, как возможности 
трассировки, объектная персистентность, регистрация исключений и так 
далее.</p>
<h3>Краткий обзор объектно-ориентированного программирования (ООП)</h3>
<p>Давайте, потратив полминуты, вспомним, что такое ООП. В языке 
объектно-ориентированного программирования можно определять классы, 
задача которых — объединить связанные данные и поведение. Эти классы 
могут наследовать некоторые или все свойства своих родителей, они также 
определяют свои собственные атрибуты (данные) или методы (поведение). В 
результате, классы, как правило, выступают в качестве шаблонов для 
создания экземпляров (которые время от времени называют просто 
объектами). Различные экземпляры одного и того же класса обычно имеют 
разные данные, хотя они будут представлены в одинаковом виде, например, у
 обоих объектов класса ‘Employee’ bob и jane есть .salary и 
.room_number, но значения room (комната) и salary (жалование) у каждого 
различны.</p>
<p>Некоторые объектно-ориентированные языки программирования, включая 
Python, предусматривают интроспективные (или рефлексивные) объекты. 
Другими словами, интроспективный объект может сам себя описывать: к 
какому классу принадлежит этот экземпляр? Кто предки этого класса? Какие
 методы и атрибуты доступны объекту? Интроспекция позволяет функции или 
методу, управляющему объектами, принимать решения, основываясь на том, 
какой вид объекта передается. Даже без интроспекции функции часто 
ветвятся, опираясь на данные экземпляра — например, маршрут к 
jane.room_number отличается от пути к bob.room_number, поскольку они в 
"различных комнатах" (значения room у них различны). С помощью 
интроспекции также можно безошибочно вычислить bonus (премиальные) jane,
 пропустив это вычисление для bob, например, потому что у jane есть 
атрибут .profit_share или из-за того, что bob является экземпляром 
производного класса Hourly(Employee).<br>
"Метапрограммный" ответ</p>
<p>Базовая система ООП, очерченная выше, является достаточно мощной. 
Однако, в этом описании один момент не получил должного внимания: в 
Python (и других языках) сами классы являются объектами, которые можно 
передавать и подвергать интроспекции. Но поскольку объекты, как 
отмечалось, создаются с использованием классов в качестве шаблонов, то 
что же является шаблоном для создания классов? Разумеется, метаклассы.</p>
<p>В Python всегда были метаклассы. Однако, технология, задействованная в
 метаклассах, стала гораздо более очевидной с выходом Python 2.2. А 
именно, в версии 2.2 Python перестал быть языком только с одним 
специальным (обычно невидимым) метаклассом, который создавал каждый 
объект класса. Теперь программисты могут наследоваться от встроенного 
метакласса type и даже динамически генерировать классы с различными 
метаклассами. Разумеется, только то, что вы можете манипулировать 
метаклассами на Python 2.2, еще не объясняет, зачем вам это.</p>
<p>Более того, вам не нужно использовать метаклассы, определенные 
пользователем, чтобы управлять созданием классов. Несколько менее 
головоломная концепция — фабрика классов (class factory): обыкновенная 
функция может возвращать класс, который был динамически создан в 
пределах тела функции. В традиционном синтаксисе Python вы можете 
написать:</p>
<p>Листинг 1. Традиционная фабрика классов на Python 1.5.2</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-A"><div class="block block-174 type-custom "><div class="field field-528">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 0px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="1901069998" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display: inline-table; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent;"><ins id="aswift_0_anchor" style="display: block; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="typ">Python</span><span class="pln"> </span><span class="lit">1.5</span><span class="pun">.</span><span class="lit">2</span><span class="pln"> </span><span class="pun">(#</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Jun</span><span class="pln"> </span><span class="lit">27</span><span class="pln"> </span><span class="lit">1999</span><span class="pun">,</span><span class="pln"> </span><span class="lit">11</span><span class="pun">:</span><span class="lit">23</span><span class="pun">:</span><span class="lit">01</span><span class="pun">)</span><span class="pln"> </span><span class="pun">[...]</span></li><li class="L1"><span class="typ">Copyright</span><span class="pln"> </span><span class="lit">1991</span><span class="pun">-</span><span class="lit">1995</span><span class="pln"> </span><span class="typ">Stichting</span><span class="pln"> </span><span class="typ">Mathematisch</span><span class="pln"> </span><span class="typ">Centrum</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Amsterdam</span></li><li class="L2"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> class_with_method</span><span class="pun">(</span><span class="pln">func</span><span class="pun">):</span></li><li class="L3"><span class="pun">...</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> klass</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">pass</span></li><li class="L4"><span class="pun">...</span><span class="pln"> setattr</span><span class="pun">(</span><span class="pln">klass</span><span class="pun">,</span><span class="pln"> func</span><span class="pun">.</span><span class="pln">__name__</span><span class="pun">,</span><span class="pln"> func</span><span class="pun">)</span></li><li class="L5"><span class="pun">...</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> klass</span></li><li class="L6"><span class="pun">...</span></li><li class="L7"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> say_foo</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">):</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> </span><span class="str">'foo'</span></li><li class="L8"><span class="pun">...</span></li><li class="L9"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> class_with_method</span><span class="pun">(</span><span class="pln">say_foo</span><span class="pun">)</span></li><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">()</span></li><li class="L1"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> foo</span><span class="pun">.</span><span class="pln">say_foo</span><span class="pun">()</span></li><li class="L2"><span class="pln">foo</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Функция фабрики class_with_method() динамически создает и возвращает 
класс, содержащий метод/функцию, передаваемую в эту фабрику. Сам класс 
обрабатывается в пределах тела функции до того, как он возвращен. Модуль
 new обеспечивает более лаконичное выражение, но без возможности 
определения пользователем дополнительного кода в пределах тела фабрики 
классов. Например:</p>
<p>Листинг 2. Фабрика классов в модуле new</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">import</span><span class="pln"> classobj</span></li><li class="L1"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo2</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> classobj</span><span class="pun">(</span><span class="str">'Foo2'</span><span class="pun">,(</span><span class="typ">Foo</span><span class="pun">,),{</span><span class="str">'bar'</span><span class="pun">:</span><span class="kwd">lambda</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">:</span><span class="str">'bar'</span><span class="pun">})</span></li><li class="L2"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo2</span><span class="pun">().</span><span class="pln">bar</span><span class="pun">()</span></li><li class="L3"><span class="str">'bar'</span></li><li class="L4"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo2</span><span class="pun">().</span><span class="pln">say_foo</span><span class="pun">()</span></li><li class="L5"><span class="pln">foo</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Во всех этих случаях поведение класса (Foo, Foo2) не записано 
непосредственно в виде кода, а создается посредством вызова во время 
исполнения функций с вычисляемыми аргументами. Следует подчеркнуть, что 
динамически создаются именно сами классы, а не просто экземпляры.<br>
Метаклассы: решение, требующее проблемы?<br>
"Метаклассы — большая магия, чем нужно 99% пользователей. Если вы 
задаетесь вопросом, нужны ли они вам, значит, они вам не нужны (те, кому
 они действительно нужны, точно это знают, и им не требуется объяснение,
 зачем)".<br>
Тим Питерс (Tim Peters), крупнейший авторитет в области Python</p>
<p>Методы (классов), как и обычные функции, могут возвращать объекты. В 
этом смысле очевидно, что фабрики классов столь же могут быть классами, 
как и функциями. В частности, Python 2.2+ предоставляет специальный 
класс, называемый type, который именно и есть такая фабрика классов. 
Разумеется, читатели узнают в type() менее претенциозную встроенную 
функцию более ранних версий Python — к счастью, поведение старой функции
 type() поддерживается классом type (другими словами, type(obj) 
возвращает тип/класс объекта obj). Новый класс работает в качестве 
фабрики классов точно так же, как прежде делала функция new.classobj:</p>
<p>Листинг 3. type в качестве метакласса фабрики классов</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> X </span><span class="pun">=</span><span class="pln"> type</span><span class="pun">(</span><span class="str">'X'</span><span class="pun">,(),{</span><span class="str">'foo'</span><span class="pun">:</span><span class="kwd">lambda</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">:</span><span class="str">'foo'</span><span class="pun">})</span></li><li class="L1"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> X</span><span class="pun">,</span><span class="pln"> X</span><span class="pun">().</span><span class="pln">foo</span><span class="pun">()</span></li><li class="L2"><span class="pun">(&lt;</span><span class="kwd">class</span><span class="pln"> </span><span class="str">'__main__.X'</span><span class="pun">&gt;,</span><span class="pln"> </span><span class="str">'foo'</span><span class="pun">)</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Но поскольку теперь type — это (мета)класс, вы можете создать от него производный класс:</p>
<p>Листинг 4. Потомок type как фабрика классов</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ChattyType</span><span class="pun">(</span><span class="pln">type</span><span class="pun">):</span></li><li class="L1"><span class="pun">...</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> __new__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dct</span><span class="pun">):</span></li><li class="L2"><span class="pun">...</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Allocating memory for class"</span><span class="pun">,</span><span class="pln"> name</span></li><li class="L3"><span class="pun">...</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> type</span><span class="pun">.</span><span class="pln">__new__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dct</span><span class="pun">)</span></li><li class="L4"><span class="pun">...</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> __init__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dct</span><span class="pun">):</span></li><li class="L5"><span class="pun">...</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Init'ing (configuring) class"</span><span class="pun">,</span><span class="pln"> name</span></li><li class="L6"><span class="pun">...</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">(</span><span class="typ">ChattyType</span><span class="pun">,</span><span class="pln"> cls</span><span class="pun">).</span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dct</span><span class="pun">)</span></li><li class="L7"><span class="pun">...</span></li><li class="L8"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> X </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ChattyType</span><span class="pun">(</span><span class="str">'X'</span><span class="pun">,(),{</span><span class="str">'foo'</span><span class="pun">:</span><span class="kwd">lambda</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">:</span><span class="str">'foo'</span><span class="pun">})</span></li><li class="L9"><span class="typ">Allocating</span><span class="pln"> memory </span><span class="kwd">for</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> X</span></li><li class="L0"><span class="typ">Init</span><span class="str">'ing (configuring) class X</span></li><li class="L1"><span class="str">&gt;&gt;&gt; X, X().foo()</span></li><li class="L2"><span class="str">(&lt;class '</span><span class="pln">__main__</span><span class="pun">.</span><span class="pln">X</span><span class="str">'&gt;, '</span><span class="pln">foo</span><span class="str">')</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-B"><div class="block block-175 type-custom "><div class="field field-529">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 0px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="3760946574" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display: inline-table; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent;"><ins id="aswift_1_anchor" style="display: block; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><p>Магические методы .__new__() и .__init__() являются
 специальными, но концептуально они такие же, как и у любого другого 
класса. Метод .__init__() позволяет конфигурировать созданный объект; 
метод .__new__() разрешает настраивать его создание. Последний, 
разумеется, не используется широко, но существует для каждого класса 
нового стиля Python 2.2 (обычно наследуется, а не подменяется).</p>
<p>У потомков type есть одно свойство, которое необходимо учитывать; на 
нем ловятся все, кто впервые использует метаклассы. Первый аргумент в 
методах обычно называется cls, а не self, поскольку эти методы 
обрабатывают созданный класс, а не метакласс. На самом деле, в этом нет 
ничего особенного; все методы связываются со своимиэкземплярами, а 
экземпляр метакласса является классом. Неспециальное имя делает это 
более очевидным[1]:</p>
<p>Листинг 5. Прикрепление методов класса к созданным классам</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Printable</span><span class="pun">(</span><span class="pln">type</span><span class="pun">):</span></li><li class="L1"><span class="pun">...</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> whoami</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">):</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"I am a"</span><span class="pun">,</span><span class="pln"> cls</span><span class="pun">.</span><span class="pln">__name__</span></li><li class="L2"><span class="pun">...</span></li><li class="L3"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Printable</span><span class="pun">(</span><span class="str">'Foo'</span><span class="pun">,(),{})</span></li><li class="L4"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">.</span><span class="pln">whoami</span><span class="pun">()</span></li><li class="L5"><span class="pln">I am a </span><span class="typ">Foo</span></li><li class="L6"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Printable</span><span class="pun">.</span><span class="pln">whoami</span><span class="pun">()</span></li><li class="L7"><span class="typ">Traceback</span><span class="pln"> </span><span class="pun">(</span><span class="pln">most recent call </span><span class="kwd">last</span><span class="pun">):</span></li><li class="L8"><span class="typ">TypeError</span><span class="pun">:</span><span class="pln"> unbound method whoami</span><span class="pun">()</span><span class="pln"> </span><span class="pun">[...]</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Вся эта удивительно непримечательная технология сопровождается некими
 синтаксическими украшениями, упрощающими работу с метаклассами и 
одновременно запутывающими новых пользователей. В этом дополнительном 
синтаксисе есть несколько элементов. Порядок интерпретации этих новых 
вариаций мудреный. Классы могут наследовать метаклассы от своих предков —
 заметьте, что это не одно и то же, что наличие метаклассов в качестве 
предков (еще одно обычное заблуждение). Для классов старого стиля 
определение глобальной переменной __metaclass__ приводит к использованию
 метаклассса, определенного пользователем. Однако по большей части самый
 безопасный подход — задать атрибут класса __metaclass__ для класса, 
который хочет быть созданным по метаклассу, определенному пользователем.
 Вы должны задать эту переменную в самом определении класса, поскольку 
метакласс не используется, если этот атрибут задан позднее (после того 
как объект класса уже был создан). Например:</p>
<p>Листинг 6. Задание метакласса с атрибутом класса</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Bar</span><span class="pun">:</span></li><li class="L1"><span class="pun">...</span><span class="pln"> __metaclass__ </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Printable</span></li><li class="L2"><span class="pun">...</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> foomethod</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">):</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> </span><span class="str">'foo'</span></li><li class="L3"><span class="pun">...</span></li><li class="L4"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Bar</span><span class="pun">.</span><span class="pln">whoami</span><span class="pun">()</span></li><li class="L5"><span class="pln">I am a </span><span class="typ">Bar</span></li><li class="L6"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="typ">Bar</span><span class="pun">().</span><span class="pln">foomethod</span><span class="pun">()</span></li><li class="L7"><span class="pln">foo</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<h3>Проблемы, решаемые магией</h3>
<p>До сих пор мы рассматривали основы метаклассов. Однако реальное 
применение метаклассов имеет свои тонкости. Сложность с использованием 
метаклассов заключается в том, что в типичной модели ООП классы в 
действительности делают не много. Структура наследования классов удобна 
для инкапсуляции и объединения данных и методов, но обычно реально 
используются именно экземпляры.</p>
<p>Существует две общие категории задач программирования, для которых, на наш взгляд, метаклассы являются чрезвычайно полезными.</p>
<p>Первый, и вероятно более общий случай, это когда в период 
проектирования вы не знаете точно, что нужно делать классу. Очевидно, 
что у вас появится представление об этом, но некая определенная деталь 
может зависеть от информации, которая станет доступной позднее. Само 
"позднее" может быть двух видов: (а) когда библиотечный модуль будет 
использоваться приложением; (б) во время исполнения, когда будет 
существовать некая ситуация. Этот категория близка к тому, что часто 
называют "Аспектно-ориентированным программированием" (АОП). 
Продемонстрируем, что мы имеем в виду на следующем элегантном примере:</p>
<p>Листинг 7. Конфигурирование метакласса во время исполнения</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-C"><div class="block block-176 type-custom "><div class="field field-530">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 0px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="3929425397" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display: inline-table; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent;"><ins id="aswift_2_anchor" style="display: block; border: medium none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 740px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">%</span><span class="pln"> cat </span><span class="kwd">dump</span><span class="pun">.</span><span class="pln">py</span></li><li class="L1"><span class="com">#!/usr/bin/python</span></li><li class="L2"><span class="kwd">import</span><span class="pln"> sys</span></li><li class="L3"><span class="kwd">if</span><span class="pln"> len</span><span class="pun">(</span><span class="pln">sys</span><span class="pun">.</span><span class="pln">argv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">2</span><span class="pun">:</span></li><li class="L4"><span class="pln"> </span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> metaklass </span><span class="pun">=</span><span class="pln"> sys</span><span class="pun">.</span><span class="pln">argv</span><span class="pun">[</span><span class="lit">1</span><span class="pun">:</span><span class="lit">3</span><span class="pun">]</span></li><li class="L5"><span class="pln"> m </span><span class="pun">=</span><span class="pln"> __import__</span><span class="pun">(</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> globals</span><span class="pun">(),</span><span class="pln"> locals</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">[</span><span class="pln">metaklass</span><span class="pun">])</span></li><li class="L6"><span class="pln"> __metaclass__ </span><span class="pun">=</span><span class="pln"> getattr</span><span class="pun">(</span><span class="pln">m</span><span class="pun">,</span><span class="pln"> metaklass</span><span class="pun">)</span></li><li class="L7"><span class="pln"> </span></li><li class="L8"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Data</span><span class="pun">:</span></li><li class="L9"><span class="pln"> </span><span class="kwd">def</span><span class="pln"> __init__</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">):</span></li><li class="L0"><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">num </span><span class="pun">=</span><span class="pln"> </span><span class="lit">38</span></li><li class="L1"><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">lst </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="str">'a'</span><span class="pun">,</span><span class="str">'b'</span><span class="pun">,</span><span class="str">'c'</span><span class="pun">]</span></li><li class="L2"><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">str </span><span class="pun">=</span><span class="pln"> </span><span class="str">'spam'</span></li><li class="L3"><span class="pln"> dumps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">lambda</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">:</span><span class="pln"> </span><span class="str">`self`</span></li><li class="L4"><span class="pln"> __str__ </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">lambda</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">dumps</span><span class="pun">()</span></li><li class="L5"><span class="pln"> </span></li><li class="L6"><span class="pln">data </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Data</span><span class="pun">()</span></li><li class="L7"><span class="kwd">print</span><span class="pln"> data</span></li><li class="L8"><span class="pln"> </span></li><li class="L9"><span class="pun">%</span><span class="pln"> </span><span class="kwd">dump</span><span class="pun">.</span><span class="pln">py</span></li><li class="L0"><span class="pun">&lt;</span><span class="pln">__main__</span><span class="pun">.</span><span class="typ">Data</span><span class="pln"> instance at </span><span class="lit">1686a0</span><span class="pun">&gt;</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Как вы могли ожидать, это приложение выводит весьма общее описание 
объекта data (условный объект экземпляра). Однако, если аргументы 
времени исполнения передаются в приложение, можно получить несколько 
отличный результат:</p>
<p>Листинг 8. Добавление метакласса внешней сериализации</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">%</span><span class="pln"> </span><span class="kwd">dump</span><span class="pun">.</span><span class="pln">py gnosis</span><span class="pun">.</span><span class="pln">magic </span><span class="typ">MetaXMLPickler</span></li><li class="L1"><span class="pun">&lt;?</span><span class="pln">xml version</span><span class="pun">=</span><span class="str">"1.0"</span><span class="pun">?&gt;</span></li><li class="L2"><span class="pun">&lt;!</span><span class="pln">DOCTYPE </span><span class="typ">PyObject</span><span class="pln"> SYSTEM </span><span class="str">"PyObjects.dtd"</span><span class="pun">&gt;</span></li><li class="L3"><span class="pun">&lt;</span><span class="typ">PyObject</span><span class="pln"> </span><span class="kwd">module</span><span class="pun">=</span><span class="str">"__main__"</span><span class="pln"> </span><span class="kwd">class</span><span class="pun">=</span><span class="str">"Data"</span><span class="pln"> id</span><span class="pun">=</span><span class="str">"720748"</span><span class="pun">&gt;</span></li><li class="L4"><span class="pun">&lt;</span><span class="pln">attr name</span><span class="pun">=</span><span class="str">"lst"</span><span class="pln"> type</span><span class="pun">=</span><span class="str">"list"</span><span class="pln"> id</span><span class="pun">=</span><span class="str">"980012"</span><span class="pln"> </span><span class="pun">&gt;</span></li><li class="L5"><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">item type</span><span class="pun">=</span><span class="str">"string"</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">=</span><span class="str">"a"</span><span class="pln"> </span><span class="pun">/&gt;</span></li><li class="L6"><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">item type</span><span class="pun">=</span><span class="str">"string"</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">=</span><span class="str">"b"</span><span class="pln"> </span><span class="pun">/&gt;</span></li><li class="L7"><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">item type</span><span class="pun">=</span><span class="str">"string"</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">=</span><span class="str">"c"</span><span class="pln"> </span><span class="pun">/&gt;</span></li><li class="L8"><span class="pun">&lt;/</span><span class="pln">attr</span><span class="pun">&gt;</span></li><li class="L9"><span class="pun">&lt;</span><span class="pln">attr name</span><span class="pun">=</span><span class="str">"num"</span><span class="pln"> type</span><span class="pun">=</span><span class="str">"numeric"</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">=</span><span class="str">"38"</span><span class="pln"> </span><span class="pun">/&gt;</span></li><li class="L0"><span class="pun">&lt;</span><span class="pln">attr name</span><span class="pun">=</span><span class="str">"str"</span><span class="pln"> type</span><span class="pun">=</span><span class="str">"string"</span><span class="pln"> </span><span class="kwd">value</span><span class="pun">=</span><span class="str">"spam"</span><span class="pln"> </span><span class="pun">/&gt;</span></li><li class="L1"><span class="pun">&lt;/</span><span class="typ">PyObject</span><span class="pun">&gt;</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>В этом частном примере применяется стиль сериализации 
gnosis.xml.pickle, но текущая версия пакета gnosis.magic также содержит 
метаклассы сериализаторов MetaYamlDump, MetaPyPickler и MetaPrettyPrint.
 Кроме того, пользователь "приложения" dump.py может потребовать 
использование любого желаемого "MetaPickler" из любого пакета Python, 
который его определяет. Соответствующий метакласс, предназначенный для 
этой цели, будет выглядеть приблизительно так:</p>
<p>Листинг 9. Добавление атрибута с метаклассом</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">class</span><span class="pln"> </span><span class="typ">MetaPickler</span><span class="pun">(</span><span class="pln">type</span><span class="pun">):</span></li><li class="L1"><span class="pln"> </span><span class="str">"Metaclass for gnosis.xml.pickle serialization"</span></li><li class="L2"><span class="pln"> </span><span class="kwd">def</span><span class="pln"> __init__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dict</span><span class="pun">):</span></li><li class="L3"><span class="pln"> </span><span class="kwd">from</span><span class="pln"> gnosis</span><span class="pun">.</span><span class="pln">xml</span><span class="pun">.</span><span class="pln">pickle </span><span class="kwd">import</span><span class="pln"> dumps</span></li><li class="L4"><span class="pln"> </span><span class="kwd">super</span><span class="pun">(</span><span class="typ">MetaPickler</span><span class="pun">,</span><span class="pln"> cls</span><span class="pun">).</span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> bases</span><span class="pun">,</span><span class="pln"> dict</span><span class="pun">)</span></li><li class="L5"><span class="pln"> setattr</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class="pln"> </span><span class="str">'dumps'</span><span class="pun">,</span><span class="pln"> dumps</span><span class="pun">)</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Замечательное достижение этого подхода заключается в том, что 
прикладному программисту не нужно ничего знать о том, какая сериализация
 будет использоваться -будет ли даже добавляться в командной строке 
сериализация или другой способ внешнего представления.</p>
<p>Возможно, наиболее общее использование метаклассов схоже с 
применением MetaPicklers: добавление, удаление, переименование или 
подстановка методов вместо методов, определенных в созданном классе. В 
нашем примере "встроенный" метод Data.dump() заменяется другим методом, 
внешним по отношению к приложению, во время создания класса Data (и, 
следовательно, в каждом последующем экземпляре).<br>
Другие способы решения проблем с помощью магии</p>
<p>Существует область программирования, где классы зачастую более важны,
 чем экземпляры. Например, декларативные мини-языки (declarative 
mini-languages) — это библиотеки Python, программная логика которых 
выражена непосредственно в объявлении класса. Дэвид рассматривает их в 
своей статье "Создание декларативных мини-языков" (Create declarative 
mini-languages). В подобных случаях использование метаклассов для 
воздействия на процесс создания класса может быть весьма эффективным.</p>
<p>Одной из декларативных библиотек, основанных на классах, является 
gnosis.xml.validity. В этой структуре вы объявляете ряд "классов 
допустимости" ("validity classes"), которые описывают набор ограничений 
для допустимых документов XML. Эти объявления очень близки к тем, что 
содержатся в описаниях типа документа (DTDs). Например, документ 
"диссертация" может быть сконфигурирован с помощью следующего кода:</p>
<p>Листинг 10. Правила gnosis.xml.validity в simple_diss.py</p>
<div class="a69fc18d" data-region="main-content" data-finished="true"><div class="group group-D"><div class="block block-177 type-custom "><div class="field field-531">
<ins class="adsbygoogle" style="display: block; text-align: center; height: 185px;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7264282846152864" data-ad-slot="2005011772" data-adsbygoogle-status="done"><ins id="aswift_3_expand" style="display:inline-table;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><ins id="aswift_3_anchor" style="display:block;border:none;height:185px;margin:0;padding:0;position:relative;visibility:visible;width:740px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_3" name="aswift_3" style="left:0;position:absolute;top:0;width:740px;height:185px;" width="740" height="185" frameborder="0"></iframe></ins></ins></ins>
</div>
</div></div></div><div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">from</span><span class="pln"> gnosis</span><span class="pun">.</span><span class="pln">xml</span><span class="pun">.</span><span class="pln">validity </span><span class="kwd">import</span><span class="pln"> </span><span class="pun">*</span></li><li class="L1"><span class="kwd">class</span><span class="pln"> figure</span><span class="pun">(</span><span class="pln">EMPTY</span><span class="pun">):</span><span class="pln"> </span><span class="kwd">pass</span></li><li class="L2"><span class="kwd">class</span><span class="pln"> _mixedpara</span><span class="pun">(</span><span class="typ">Or</span><span class="pun">):</span><span class="pln"> _disjoins </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">PCDATA</span><span class="pun">,</span><span class="pln"> figure</span><span class="pun">)</span></li><li class="L3"><span class="kwd">class</span><span class="pln"> paragraph</span><span class="pun">(</span><span class="typ">Some</span><span class="pun">):</span><span class="pln"> _type </span><span class="pun">=</span><span class="pln"> _mixedpara</span></li><li class="L4"><span class="kwd">class</span><span class="pln"> title</span><span class="pun">(</span><span class="pln">PCDATA</span><span class="pun">):</span><span class="pln"> </span><span class="kwd">pass</span></li><li class="L5"><span class="kwd">class</span><span class="pln"> _paras</span><span class="pun">(</span><span class="typ">Some</span><span class="pun">):</span><span class="pln"> _type </span><span class="pun">=</span><span class="pln"> paragraph</span></li><li class="L6"><span class="kwd">class</span><span class="pln"> chapter</span><span class="pun">(</span><span class="typ">Seq</span><span class="pun">):</span><span class="pln"> _order </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">title</span><span class="pun">,</span><span class="pln"> _paras</span><span class="pun">)</span></li><li class="L7"><span class="kwd">class</span><span class="pln"> dissertation</span><span class="pun">(</span><span class="typ">Some</span><span class="pun">):</span><span class="pln"> _type </span><span class="pun">=</span><span class="pln"> chapter</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Если попытаться создать экземпляр dissertation без надлежащих 
подэлементов, возбуждается исключение, описывающее ситуацию; подобное 
имеет место для каждого подэлемента. Правильные подэлементы будут 
автоматически сгенерированы из более простых аргументов, если существует
 только один непротиворечивый способ "достроить" тип до корректного 
состояния.</p>
<p>Хотя классы допустимости часто (неформально) базируются на 
предварительно существующем DTD, экземпляры этих классов печатаются как 
внеконтекстные (unadorned) фрагменты документа XML, например:</p>
<p>Листинг 11. Создание документа с базовым классом допустимости</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> simple_diss </span><span class="kwd">import</span><span class="pln"> </span><span class="pun">*</span></li><li class="L1"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> ch </span><span class="pun">=</span><span class="pln"> </span><span class="typ">LiftSeq</span><span class="pun">(</span><span class="pln">chapter</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="str">'It Starts'</span><span class="pun">,</span><span class="str">'When it began'</span><span class="pun">))</span></li><li class="L2"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> ch</span></li><li class="L3"><span class="str">&lt;chapter&gt;&lt;title&gt;</span><span class="typ">It</span><span class="pln"> </span><span class="typ">Starts</span><span class="pun">&lt;/</span><span class="pln">title</span><span class="pun">&gt;</span></li><li class="L4"><span class="str">&lt;paragraph&gt;</span><span class="typ">When</span><span class="pln"> it began</span><span class="pun">&lt;/</span><span class="pln">paragraph</span><span class="pun">&gt;</span></li><li class="L5"><span class="pun">&lt;/</span><span class="pln">chapter</span><span class="pun">&gt;</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Используя метакласс для создания классов допустимости, мы можем 
генерировать DTD из самих объявлений класса (и при этом добавить 
дополнительный метод в эти классы):</p>
<p>Листинг 12. Использование метаклассов во время импорта модуля</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> gnosis</span><span class="pun">.</span><span class="pln">magic </span><span class="kwd">import</span><span class="pln"> </span><span class="typ">DTDGenerator</span><span class="pun">,</span><span class="pln"> </span></li><li class="L1"><span class="pun">...</span><span class="pln"> import_with_metaclass</span><span class="pun">,</span><span class="pln"> </span></li><li class="L2"><span class="pun">...</span><span class="pln"> from_import</span></li><li class="L3"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> import_with_metaclass</span><span class="pun">(</span><span class="str">'simple_diss'</span><span class="pun">,</span><span class="typ">DTDGenerator</span><span class="pun">)</span></li><li class="L4"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> from_import</span><span class="pun">(</span><span class="pln">d</span><span class="pun">,</span><span class="str">'**'</span><span class="pun">)</span></li><li class="L5"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> ch </span><span class="pun">=</span><span class="pln"> </span><span class="typ">LiftSeq</span><span class="pun">(</span><span class="pln">chapter</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="str">'It Starts'</span><span class="pun">,</span><span class="str">'When it began'</span><span class="pun">))</span></li><li class="L6"><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="kwd">print</span><span class="pln"> ch</span><span class="pun">.</span><span class="pln">with_internal_subset</span><span class="pun">()</span></li><li class="L7"><span class="pun">&lt;?</span><span class="pln">xml version</span><span class="pun">=</span><span class="str">'1.0'</span><span class="pun">?&gt;</span></li><li class="L8"><span class="pun">&lt;!</span><span class="pln">DOCTYPE chapter </span><span class="pun">[</span></li><li class="L9"><span class="pun">&lt;!</span><span class="pln">ELEMENT figure EMPTY</span><span class="pun">&gt;</span></li><li class="L0"><span class="pun">&lt;!</span><span class="pln">ELEMENT dissertation </span><span class="pun">(</span><span class="pln">chapter</span><span class="pun">)+&gt;</span></li><li class="L1"><span class="pun">&lt;!</span><span class="pln">ELEMENT chapter </span><span class="pun">(</span><span class="pln">title</span><span class="pun">,</span><span class="pln">paragraph</span><span class="pun">+)&gt;</span></li><li class="L2"><span class="pun">&lt;!</span><span class="pln">ELEMENT title </span><span class="pun">(#</span><span class="pln">PCDATA</span><span class="pun">)&gt;</span></li><li class="L3"><span class="pun">&lt;!</span><span class="pln">ELEMENT paragraph </span><span class="pun">((#</span><span class="pln">PCDATA</span><span class="pun">|</span><span class="pln">figure</span><span class="pun">))+&gt;</span></li><li class="L4"><span class="pun">]&gt;</span></li><li class="L5"><span class="str">&lt;chapter&gt;&lt;title&gt;</span><span class="typ">It</span><span class="pln"> </span><span class="typ">Starts</span><span class="pun">&lt;/</span><span class="pln">title</span><span class="pun">&gt;</span></li><li class="L6"><span class="str">&lt;paragraph&gt;</span><span class="typ">When</span><span class="pln"> it began</span><span class="pun">&lt;/</span><span class="pln">paragraph</span><span class="pun">&gt;</span></li><li class="L7"><span class="pun">&lt;/</span><span class="pln">chapter</span><span class="pun">&gt;</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>Пакету gnosis.xml.validity ничего неизвестно о DTD и внутренних 
подмножествах. Эти концепции и возможности всецело представлены 
метаклассом DTDGenerator без внесения каких-либо изменений в 
gnosis.xml.validity или simple_diss.py. DTDGenerator не подставляет свой
 собственный метод .__str__() в классы, которые он создает — вы 
по-прежнему можете вывести внеконтекстный фрагмент XML — но метакласс 
мог бы легко модифицировать подобные магические методы.<br>
Метапреимущества</p>
<p>Пакет gnosis.magic содержит несколько утилит для работы с 
метаклассами, а также некоторые примеры метаклассов, которые можно 
применять в аспектно-ориентированном программировании. Наиболее важная 
из этих утилит — import_with_metaclass(). Эта функция, задействованная в
 предыдущем примере, позволяет импортировать произвольный модуль, 
создавая все классы этого модуля с использованием метакласса, 
определенного пользователем, а не type. Какую бы новую возможность вы ни
 захотели задать в этом модуле, она может быть определена в метаклассе, 
который вы создаете (или получаете). gnosis.magic содержит некоторые 
подключаемые метаклассы сериализации; другой пакет мог бы включать 
возможности трассировки, объектную персистентность, регистрацию 
исключений или же что-нибудь еще.</p>
<p>Функция import_with_metaclass() иллюстрирует некоторые возможности программирования метаклассов:</p>
<p>Листинг 13. Функция import_with_metaclass() из [gnosis.magic]</p>
<div class="prettyprint-wrap"><p style=" font-family:'Courier New,Courier,sans-serif'; background-color:#eff0f1; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><ol class="linenums"><li class="L0"><span class="kwd">def</span><span class="pln"> import_with_metaclass</span><span class="pun">(</span><span class="pln">modname</span><span class="pun">,</span><span class="pln"> metaklass</span><span class="pun">):</span></li><li class="L1"><span class="pln"> </span><span class="str">"Module importer substituting custom metaclass"</span></li><li class="L2"><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Meta</span><span class="pun">(</span><span class="kwd">object</span><span class="pun">):</span><span class="pln"> __metaclass__ </span><span class="pun">=</span><span class="pln"> metaklass</span></li><li class="L3"><span class="pln"> dct </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="str">'__module__'</span><span class="pun">:</span><span class="pln">modname</span><span class="pun">}</span></li><li class="L4"><span class="pln"> mod </span><span class="pun">=</span><span class="pln"> __import__</span><span class="pun">(</span><span class="pln">modname</span><span class="pun">)</span></li><li class="L5"><span class="pln"> </span><span class="kwd">for</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> val </span><span class="kwd">in</span><span class="pln"> mod</span><span class="pun">.</span><span class="pln">__dict__</span><span class="pun">.</span><span class="pln">items</span><span class="pun">():</span></li><li class="L6"><span class="pln"> </span><span class="kwd">if</span><span class="pln"> inspect</span><span class="pun">.</span><span class="pln">isclass</span><span class="pun">(</span><span class="pln">val</span><span class="pun">):</span></li><li class="L7"><span class="pln"> setattr</span><span class="pun">(</span><span class="pln">mod</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> type</span><span class="pun">(</span><span class="pln">key</span><span class="pun">,(</span><span class="pln">val</span><span class="pun">,</span><span class="typ">Meta</span><span class="pun">),</span><span class="pln">dct</span><span class="pun">))</span></li><li class="L8"><span class="pln"> </span><span class="kwd">return</span><span class="pln"> mod</span></li></ol></p><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; font-size:10px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></div>
<p>В этой функции стоит обратить внимание на стиль — обыкновенный класс 
Meta создан с использованием заданного метакласса. Но как только Meta 
добавлен в качестве предка, его потомки также создаются с помощью этого 
метакласса. В принципе, класс, подобный Meta, мог бы предоставлять и 
генератор метакласса, и ряд наследуемых методов — эти два аспекта 
наследования являются ортогональными.</p>
    </main>
</body>
</html></p></body></html>